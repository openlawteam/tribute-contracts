"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5497],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return h}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),u=l(n),h=o,m=u["".concat(c,".").concat(h)]||u[h]||p[h]||i;return n?a.createElement(m,s(s({ref:t},d),{},{components:n})):a.createElement(m,s({ref:t},d))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,s=new Array(i);s[0]=u;var r={};for(var c in t)hasOwnProperty.call(t,c)&&(r[c]=t[c]);r.originalType=e,r.mdxType="string"==typeof e?e:o,s[1]=r;for(var l=2;l<i;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},3422:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return d},default:function(){return u}});var a=n(7462),o=n(3366),i=(n(7294),n(3905)),s=["components"],r={id:"creating-an-extension",title:"How to create an Extension"},c=void 0,l={unversionedId:"tutorial/extensions/creating-an-extension",id:"tutorial/extensions/creating-an-extension",isDocsHomePage:!1,title:"How to create an Extension",description:"Extensions are reusable smart contracts that add additional capabilities to the DAO without cluttering the core contracts with complex logic.",source:"@site/docs/tutorial/extensions/HowToCreateAnExtension.md",sourceDirName:"tutorial/extensions",slug:"/tutorial/extensions/creating-an-extension",permalink:"/docs/tutorial/extensions/creating-an-extension",editUrl:"https://github.com/openlawteam/tribute-contracts/edit/docs/website/docs/tutorial/extensions/HowToCreateAnExtension.md",tags:[],version:"current",frontMatter:{id:"creating-an-extension",title:"How to create an Extension"},sidebar:"docs",previous:{title:"How to create an Adapter",permalink:"/docs/tutorial/adapters/creating-an-adapter"},next:{title:"Registry",permalink:"/docs/contracts/core/dao-registry"}},d=[{value:"Defining the Interface",id:"defining-the-interface",children:[]},{value:"Map out the proper Access Flags",id:"map-out-the-proper-access-flags",children:[]},{value:"Set up the DAO custom configurations",id:"set-up-the-dao-custom-configurations",children:[]},{value:"Be mindful of the storage costs",id:"be-mindful-of-the-storage-costs",children:[]},{value:"Conventions &amp; Implementation",id:"conventions--implementation",children:[]},{value:"Testing the new Extension",id:"testing-the-new-extension",children:[]},{value:"Adding documentation",id:"adding-documentation",children:[]},{value:"Done",id:"done",children:[]}],p={toc:d};function u(e){var t=e.components,n=(0,o.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/intro/design/extensions/introduction"},"Extensions")," are reusable smart contracts that add additional capabilities to the DAO without cluttering the core contracts with complex logic."),(0,i.kt)("p",null,"The key difference between an ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/tutorial/adapters/creating-an-adapter"},"Adapter"))," and an ",(0,i.kt)("strong",{parentName:"p"},"Extension"),", is that adapters are not tied to a specific DAO address, so you can use the exact same Adapter to perform actions in different DAOs. While the ",(0,i.kt)("strong",{parentName:"p"},"Extensions")," are instantiate and associated to a particular DAO, because an extension can track additional state information of that DAO, and is used as an extension of the DAO core features. It means that a Core contract is allowed to execute calls to an Extension, but not to an Adapter."),(0,i.kt)("p",null,"Each extension needs to be configured with the DaoRegistry ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/contracts/core/dao-registry#access-flags"},"Access Flags"))," in order to access the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/intro/design/core/introduction"},"Core Contracts")),", but it also can define its own Access Flags that will be required if an Adapter interacts with it."),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Extensions can defined their own Access Flags to restrict access to its functions. Any Adapter that needs to interact with the extension needs to configure the custom access flags."))),(0,i.kt)("h3",{id:"defining-the-interface"},"Defining the Interface"),(0,i.kt)("p",null,"The extension must implement the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/openlawteam/tribute-contracts/blob/master/contracts/extensions/IExtension.sol"},"IExtension")," to be able to initialize the extension and set the correct DAO address that it belongs to."),(0,i.kt)("p",null,"It is a good practice to always verify if the extension was not initialized, and if the creator is a DAO member, otherwise the extension creation call might be hijacked."),(0,i.kt)("p",null,"If your extension will be used by adapters only, you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"AdapterGuard")," function ",(0,i.kt)("inlineCode",{parentName:"p"},"onlyAdapter")," to check if the adapter is registered in the DAO and is allowed to call your extension."),(0,i.kt)("p",null,"Here is a simple implementation that performs the verification:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},'contract MyExtension is DaoConstants, IExtension {\n  // Internally tracks deployment under eip-1167 proxy pattern\n  bool public initialized = false;\n\n  // The DAO address that is the owner of this extension\n  DaoRegistry public dao;\n\n  /// @notice Clonable contract must have an empty constructor\n  constructor() {}\n\n  /**\n   * @notice Initializes the extension to be associated with a DAO\n   * @dev Can only be called once\n   * @param creator The DAO\'s creator, who will be an initial member\n   */\n  function initialize(DaoRegistry _dao, address creator) external override {\n    require(!initialized, "executor::already initialized");\n    require(_dao.isMember(creator), "executor::not member");\n    dao = _dao;\n    initialized = true;\n  }\n}\n\n')),(0,i.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Make sure you implement the initialization function to check if the creator belongs to the DAO, and if the extension was not initialized yet."))),(0,i.kt)("h3",{id:"map-out-the-proper-access-flags"},"Map out the proper Access Flags"),(0,i.kt)("p",null,"Another important point is to map out which sort of permissions your extension will require, so other client can set that up before using it."),(0,i.kt)("p",null,"In order to configure the access control layer in your extension, we use the same ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/contracts/core/access-control"},"Access Flags"))," concept that we have in the Core contracts. For that we can define:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Which flags the extension will require."),(0,i.kt)("li",{parentName:"ol"},"The guard implementation that will verify if the caller is allowed to execute the call.")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},'\n  enum AclFlag { EXECUTE }\n\n  modifier hasExtensionAccess(AclFlag flag) {\n        require(\n            // 1. Allowed if the extension is calling itself\n               address(this) == msg.sender ||\n            // 2. Allowed if the DAO is calling the extension\n                address(dao) == msg.sender ||\n            // 3. Allowed if the DAO state is in CREATION mode\n                DaoHelper.isInCreationModeAndHasAccess(dao) ||\n            // 4. Allowed if the sender is a registered adapter\n                dao.hasAdapterAccessToExtension(\n                    msg.sender,\n                    address(this),\n                    uint8(flag)\n                ),\n            // 5. Revert message\n            "myExtension::accessDenied"\n        );\n        _;\n    }\n\n')),(0,i.kt)("p",null,"In the example above we want to allow the call execution in 4 different scenarios:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The extension is calling itself:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"useful if you have some sort of proxy pattern or delegate call."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The DAO is calling the extension:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"when the DAO needs to read/write info to the extension."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The DAO state is in CREATION mode:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"when the DAO is configuring the new extension during the ",(0,i.kt)("inlineCode",{parentName:"li"},"dao.addExtension")," call."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The sender is a registered adapter:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"an adapter uses the extension to read/write info.")))),(0,i.kt)("h3",{id:"set-up-the-dao-custom-configurations"},"Set up the DAO custom configurations"),(0,i.kt)("p",null,"In some cases extensions might need customized configurations to make decisions on the fly. These configurations can and should be set per DAO. In order to do that you have to identify which configuration parameters you need, and set them up through a proposal process via ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/contracts/adapters/configuration/configuration-adapter"},"Configuration Adapter")),". You can find an example of the usage in the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/contracts/extensions/erc20-extension#transfer"},"ERC20 Extension")),"."),(0,i.kt)("p",null,"In order to access the configuration parameter in your extension you can simply call this function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},'\n  uint256 myConfig = dao.getConfiguration("myExtension.config.name");\n\n')),(0,i.kt)("h3",{id:"be-mindful-of-the-storage-costs"},"Be mindful of the storage costs"),(0,i.kt)("p",null,"The extension usually saves additional state that we don't want to propagate to the DAO Registry, however it is important to try to not use the storage that much. We prefer efficient and cheap extensions that can be easily deployable and maintainable. The less state it maintains and operations it executes, the better."),(0,i.kt)("h3",{id:"conventions--implementation"},"Conventions & Implementation"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Function names (public)"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"myFunctionX"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Function names (private)"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"_","myFunctionX"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Revert as early as possible")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Make sure you add the correct ",(0,i.kt)("inlineCode",{parentName:"p"},"require")," checks"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Usually the extension needs to perform some verifications before executing the calls that may change the DAO state. Double check if the DAORegistry functions that your extension uses already implement some checks, so you do not need to repeat them in the adapter."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Update the DaoHelper"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"If you are creating an extension that does not have the ",(0,i.kt)("inlineCode",{parentName:"li"},"keccak256")," id declared in the ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/openlawteam/tribute-contracts/blob/master/contracts/helpers/DaoHelper.sol"},"DaoHelper")," make sure you add it there."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Add the correct function guards"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"onlyAdapter"),(0,i.kt)("li",{parentName:"ul"},"hasExtensionAccess")))),(0,i.kt)("p",null,"After creating the functions that your extension will expose, and setting the correct guards, names, and conventions you should have, at this state, an extension code similar to the following example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},'contract MyExtension is DaoConstants, IExtension {\n  // Internally tracks deployment under eip-1167 proxy pattern\n  bool public initialized = false;\n\n  // The DAO address that is the owner of this extension\n  DaoRegistry public dao;\n\n  enum AclFlag { EXECUTE }\n\n  modifier hasExtensionAccess(AclFlag flag) {\n    require(\n      // 1. Allowed if the extension is calling itself\n      address(this) == msg.sender ||\n        // 2. Allowed if the DAO is calling the extension\n        address(dao) == msg.sender ||\n        // 3. Allowed if the DAO state is in CREATION mode\n        DaoHelper.isInCreationModeAndHasAccess(dao) ||\n        // 4. Allowed if the sender is a registered adapter\n        dao.hasAdapterAccessToExtension(msg.sender, address(this), uint8(flag)),\n      // 5. Revert message\n      "myExtension::accessDenied"\n    );\n    _;\n  }\n\n  /**\n   * @notice Initializes the extension to be associated with a DAO\n   * @dev Can only be called once\n   * @param creator The DAO\'s creator, who will be an initial member\n   */\n  function initialize(DaoRegistry _dao, address creator) external override {\n    require(!initialized, "executor::already initialized");\n    require(_dao.isMember(creator), "executor::not member");\n    dao = _dao;\n    initialized = true;\n  }\n\n  function myFunctionX(DaoRegistry dao, ...)\n    onlyAdapter(dao)  // checks if the caller is an adapter\n    hasExtensionAccess(AclFlag.EXECUTE) // checks if the caller has access to this function.\n    external {\n      ... impl\n    }\n}\n\n')),(0,i.kt)("p",null,"Since the extension code is ready to be deployed, we need a way to instantiate the extension contract. For that we a CloneFactory pattern for each new extension we created, so it becomes very cheap to deploy new versions of your extensions to different DAOs because the clone happens based on the identify extension address, and all state is fresh, so there is no state sharing between different DAOs."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"contract MyExtensionFactory is CloneFactory, DaoConstants {\n  address public identityAddress;\n\n  event MyExtensionCreated(address myExtensionAddress);\n\n  constructor(address _identityAddress) {\n    identityAddress = _identityAddress;\n  }\n\n  /**\n   * @notice Create and initialize a new instance of MyExtension\n   * @param x1 Any parameter that you may want to set before it gets initialized.\n   */\n  function create(uint256 x1) external {\n    MyExtension myExtension = MyExtension(_createClone(identityAddress));\n    myExtension.setParamX1(x1);\n    emit MyExtensionCreated(address(myExtension));\n  }\n}\n\n")),(0,i.kt)("p",null,"The factory also needs to be declared in the"),(0,i.kt)("h3",{id:"testing-the-new-extension"},"Testing the new Extension"),(0,i.kt)("p",null,"In order to verify if the new extension works properly, one needs to implement the basic test suite, so we can ensure it is actually doing what it was supposed to do."),(0,i.kt)("p",null,"There are several examples of tests that you can check to start building your own. Take a look at the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"https://github.com/openlawteam/tribute-contracts/tree/master/test/extensions"},"tests/extensions")),"."),(0,i.kt)("p",null,"The general idea is to create one test suite per extension/contract. And try to cover all the happy paths first, and then add more complex and negative test cases after that."),(0,i.kt)("p",null,"You need to declare the new extension and factory contracts in ",(0,i.kt)("inlineCode",{parentName:"p"},"migrations/configs/contracts.config.js")," file, so both contracts can be accessed in the deploy/test environment. Make sure you use following the structure:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'  {\n    id: extensionsIdsMap.MY_EXTENSION,\n    name: "MyExtension",\n    alias: "myExt",\n    path: "../../contracts/extensions/path/MyExtension",\n    enabled: true,\n    version: "1.0.0",\n    type: ContractType.Extension,\n    buildAclFlag: entryMyExtension,\n    acls: {\n      dao: [],\n      extensions: {},\n    },\n  },\n  {\n    id: "my-extension-factory",\n    name: "MyExtensionFactory",\n    alias: "myExtFactory",\n    path: "../../contracts/extensions/path/MyExtensionFactory",\n    enabled: true,\n    version: "1.0.0",\n    type: ContractType.Factory,\n    acls: {\n      dao: [],\n      extensions: {},\n    },\n    generatesExtensionId: extensionsIdsMap.MY_EXTENSION,\n  },\n')),(0,i.kt)("p",null,"The attributes of the contract configuration are defined below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * Each contract contains different configurations that will be required by the deployment\n * script. This type helps you to define these configs.\n */\nexport type ContractConfig = {\n  /**\n   * The id of the contract, usually it is imported from dao-ids-util.ts.\n   */\n  id: string;\n  /**\n   *  The name of the solidity contract, not the file name, but the contract itself.\n   */\n  name: string;\n  /**\n   * The javascript variable name that will be named\n   * to access the contract. This is useful for variables\n   * that are created during the deployment such as\n   * adapters and extension. Using this alias you will be\n   * able to access it in the test context,\n   * e.g: adapters.<alias> will return the deployed contract.\n   */\n  alias?: string;\n  /**\n   * The path to the solidity contract.\n   */\n  path: string;\n  /**\n   * If true indicates that the contract must be deployed.\n   */\n  enabled: boolean;\n  /**\n   * Optional\n   * skip auto deploy true indicates that the contract do need to be\n   * automatically deployed during the migration script execution.\n   * It is useful to skip the auto deploy for contracts that are not required\n   * to launch a DAO, but that you manually configure them after the DAO is created,\n   * but not finalized, e.g: Offchain Voting.\n   */\n  skipAutoDeploy?: boolean;\n  /**\n   * Version of the solidity contract.\n   * It needs to be the name of the contract, and not the name of the .sol file.\n   */\n  version: string;\n  /**\n   * Type of the contract based on the ContractType enum.\n   */\n  type: ContractType;\n  /**\n   * The Access Control Layer flags selected to be granted to this contract in the DAO.\n   */\n  acls: SelectedACLs;\n  /**\n   * Optional\n   * The function that computes the correct ACL value based on the selected ACL flags.\n   */\n  buildAclFlag?: ACLBuilder;\n  /**\n   * Optional\n   * A contract may need custom arguments during the deployment time,\n   * declare here all the arguments that are read from the env,\n   * and passed to the configuration/deployment functions.\n   * The names of the arguments must match the arguments provided\n   * in the deployment script 2_deploy_contracts.js\n   */\n  deploymentArgs?: Array<string>;\n  /**\n   * Optional\n   * Set of arguments to be passed to the `configureDao` call\n   * after the contract has been deployment.\n   */\n  daoConfigs?: Array<Array<string>>;\n  /**\n   * Optional\n   * The id of the extension generated by the factory, usually you will import that from extensionsIdsMap.\n   * e.g: a BankFactory generates instances of contract BankContract, so the BankFactory config needs to\n   * set the extensionsIdsMap.BANK_EXT in this attribute to indicate it generates bank contracts.\n   */\n  generatesExtensionId?: string;\n};\n")),(0,i.kt)("p",null,"After adding the config to the file, next time you run the tests or the migration script, your new extension will be auto deployed."),(0,i.kt)("p",null,"In order to speed up the test suites we usually don't create one DAO per test function, but we create the DAO during the suite initialization, and then only reset the chain after each test case using the evm snapshot feature. For instance:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'describe("Extension - ExtensionName", () => {\n  /**\n   * Using the utility function `deployDefaultDao` * to create the DAO before all tests are\n   * executed.\n   * Once the DAO is created you can access the\n   * adapters, extensions, factories, testContracts\n   * and votingHelpers contracts. Use the test global scope\n   * to store them and access it later in the test functions.\n   */\n  before("deploy dao", async () => {\n    const {\n      dao,\n      adapters,\n      extensions,\n      factories,\n      testContracts,\n      votingHelpers,\n    } = await deployDefaultDao({ owner });\n    this.dao = dao;\n    this.adapters = adapters;\n    this.extensions = extensions;\n  });\n\n  /**\n   * Before each test function we take a chain snapshot, which\n   * contains the fresh DAO configurations with zero\n   * modifications.\n   */\n  beforeEach(async () => {\n    this.snapshotId = await takeChainSnapshot();\n  });\n\n  /**\n   * After the test function is executed we revert to the\n   * latest chain snapshot took when the DAO was fresh\n   * installed.\n   * With this approach we save time in the DAO creation,\n   * and the test suite runs 10x faster.\n   */\n  afterEach(async () => {\n    await revertChainSnapshot(this.snapshotId);\n  });\n\n  /**\n   * Add a descriptive name to your test function that\n   * covers the use case that you are testing.\n   */\n  it("should be possible to ...", async () => {\n    // Access the global scope to read the contracts you may need.\n    const dao = this.dao;\n    const configuration = this.adapters.configuration;\n    const voting = this.adapters.voting;\n\n    // Use openzeppelin test-env to assert results, events,and failures, e.g:\n    expect(value1.toString()).equal("1");\n    expectEvent(tx.receipt, "EventName", {\n      eventArg1: value1,\n      eventArg2: toBN("2"), //value 2\n    });\n    await expectRevert(\n      // Calling the contract function that returns promise\n      configuration.submitProposal(dao.address, "0x1", [key], [], [], {\n        from: owner,\n        gasPrice: toBN("0"),\n      }),\n      "must be an equal number of config keys and values"\n    );\n  });\n});\n')),(0,i.kt)("p",null,"You may need to use an Adapter to test your new extension functions that are protected with the ",(0,i.kt)("inlineCode",{parentName:"p"},"adapterOnly")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"hasExtensionAccess")," guards, you can ignore that if you have defined public functions that do not use any of these guards."),(0,i.kt)("p",null,"These adapters are known as Utility Adapters, we currently have some of them to access the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/contracts/adapters/utils/bank-adapter"},"Bank"))," and ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/contracts/adapters/utils/nft-adapter"},"NFT"))," Extensions, or you can simply modify one of the existing adapters to access your new extensions as defined in the tutorial ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/tutorial/adapters/creating-an-adapter#testing-the-new-adapter"},"How to create an adapter")),"."),(0,i.kt)("h3",{id:"adding-documentation"},"Adding documentation"),(0,i.kt)("p",null,"Each extension must provide its own documentation describing what is the use-case it solves, what are the functions and interactions it contains. Examples of that can be found in the existing extensions documentation ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"/docs/contracts/extensions/bank-extension"},"here")),"."),(0,i.kt)("h3",{id:"done"},"Done"),(0,i.kt)("p",null,"If you have followed all the steps above and created a well tested, documented Extension, please submit a Pull Request to ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"https://github.com/openlawteam/tribute-contracts/pulls"},"Tribute Contracts")),", so we can review it and provide additional feedback. Thank you!"))}u.isMDXComponent=!0}}]);